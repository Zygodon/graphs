---
title: "Graphs"
output: html_notebook
---
working in Correlations notebook with network D3 led to looking at igraph. Here I want to explore igraph possibly adding Network_D3 /ggplot2 later fo enhanced interactivity. Exploring the idea of using a force network with two kinds of node; species and assemblies. Species linked together by some correlation based distance measure (check out odds ratio). Decided to usee correlation coefficient r with distance measure (1-r). Assemblies not linked together but joined to species by presence/absence or possibly some P(hit) based measure. Start with  not too big a subset, say mg5c and top 12 commonest species (so can ColorBrewer palette).

Load up some data ...
```{r}
# Libraries
library("RMySQL")
library(tidyverse)
# library(corrplot)
library(networkD3)
library(igraph)

# Functions
dbDisconnectAll <- function(){
  ile <- length(dbListConnections(MySQL())  )
  lapply( dbListConnections(MySQL()), function(x) dbDisconnect(x) )
  cat(sprintf("%s connection(s) closed.\n", ile))
}

# General SQL query
query <- function(q)
{
  # Remote DB with password
  con <- dbConnect(MySQL(), 
                   user  = "guest",
                   password    = "guest",
                   dbname="meadows",
                   port = 3306,
                   host   = "sxouse.ddns.net")
  rs1 = dbSendQuery(con, q)
  return(as_tibble(fetch(rs1, n=-1)))
  dbDisconnectAll()
}

# Load the database
GetTheData <-  function()
{
  # GET DATA FROM DB
  # Remote DB with password
  con <- dbConnect(MySQL(), 
                   user  = "guest",
                   password    = "guest",
                   dbname="meadows",
                   port = 3306,
                   host   = "sxouse.ddns.net")
  
  
  q <- sprintf('select assembly_id, assembly_name, quadrat_count, community, quadrat_id, visit_date, records_id, species.species_id, 
    species.species_name from assemblies
      join quadrats on quadrats.assembly_id = assemblies_id
      join visit_dates on quadrats.vd_id = visit_dates.vds_id
      join records on records.quadrat_id = quadrats_id
      join species on species.species_id = records.species_id
      # Two assemblies have 0 quadrat count; exclude A.capillaris_stolonifera;
      # exclude some odd assemblies with no assigned community
    where quadrat_count > 0 and species.species_id != 4 and community is not null;') 
      # NOTE: this extract includes "MG5", i.e. some MG5 communities where 
      # the team have not decided
      # on a sub-group.
  
  rs1 = dbSendQuery(con, q)
  return(as_tibble(fetch(rs1, n=-1)))
  dbDisconnectAll()
}

d <- GetTheData()
# the_data <- d %>% filter(grepl("MG", community))
the_data <- d %>% filter(community == "MG5c")
rm(d)
# Reduce to the 12 most frequent species
top12 <- head(the_data 
           %>% group_by(species_name) 
           %>% summarise(hits = n()) %>% arrange(desc(hits)), 12)
d <- (the_data %>% right_join(top12, by = "species_name") 
              %>% select(assembly_id, species_name))
```
I want to make force network graph so I need a data frame with source and target columns, and the correlation coefficients for the species nodes as strength of the links:
```{r}
ctbl <- cor(table(d %>% group_by(assembly_id)))
ctbl2 <- as_tibble(ctbl) %>% mutate(source = rownames(ctbl))
edges <- (ctbl2 %>% pivot_longer(Anthoxanthum_odoratum:Trifolium_repens, names_to = "dest", values_to = "r")
          %>% filter(abs(r) > 0.2)
          %>% mutate(value = 50*(1-r))
          %>% select(source, dest, value)
          %>% mutate(group = "plants"))
```
Add more edges, from assemblies to species. NOTE: summarise r using n() not n_distinct as below gives an opportunity for a P value here.
```{r}
edg2 <- (d %>% group_by(assembly_id, species_name) 
          %>% summarise(value = n_distinct(species_name))
          %>% mutate(source = as.character(assembly_id))
          %>% ungroup()
          %>% select(source, species_name, value)
          %>% rename(dest = species_name)
          %>% mutate(group = "assemblies"))
edges <- bind_rows(edges, edg2)

```
Make nodes; list of plants and assemblies.
```{r}
nodes <- edges %>% select(source, group) %>% distinct()

```
Should be able to make a force network now ...
```{r}
net <- graph_from_data_frame(d=edges, vertices=nodes, directed=F)
plot(net)
```
(The network above is essentially a bipartite network, which may require special treatment.) Could think about a network with assemblies as nodes and links corresonding to common species. Not quite sure what I mean by this... Consider species not connected at all, assemblies not connected at all, species connected to assemblies by occurrence possibly quantified by hits/trials.

Need a new edges data frame. Which is in fact just the data d. After a bit of messing around:
```{r}
dist.d <- d %>% group_by(assembly_id) %>% distinct() #Note distinct!
net2 <- graph_from_data_frame(d=dist.d, vertices=nodes, directed=F)
colrs <- c("tomato", "gold")
V(net2)$color <- colrs[as.factor(nodes$group)]
l <- layout.fruchterman.reingold(net2)
plot(net2, layout=l)

```

The f-r layout looks useful; thin out the connections. Make a tibble to calculate hits/trials for each species/assembly combination. Use p? Median(p) from qbeta?
```{r}
median.hits <- (the_data %>% select(assembly_id, quadrat_count, species_name)
            %>% group_by(assembly_id, quadrat_count, species_name)
            %>% summarise(hits = n())
            %>% mutate(weight = qbeta(0.5,hits+1, 1+quadrat_count-hits))
            %>% mutate(p = hits/quadrat_count))
d3 <- (left_join(dist.d, median.hits, by = c("assembly_id", "species_name"))
       %>% filter(weight > 0.5))
net3 <- graph_from_data_frame(d=d3, vertices=nodes, directed=F)
colrs <- c("tomato", "gold")
V(net3)$color <- colrs[as.factor(nodes$group)]
l <- layout.fruchterman.reingold(net3)
plot(net3, layout=l,edge.width = 3*d3$weight)

```


