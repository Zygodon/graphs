---
title: "igraph notebook 2"
output: html_notebook
---
This notebook is motivated by a couple of weeks experience thinking  about graph theory and its relevance to community structure. I have been impressed by ideas about the development of traits and co-evolution, I have a paper to quote regarding trait development and co-evolution in the relationship between plants and insect pollinators (*https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2148393/; The modularity of pollination networks; Jens M. Olesen, Jordi Bascompte, Yoko L. Dupont, and Pedro Jordano, 2007*). It occurs to me that there might be cooperative interactions between meadow plants, e.g. sharing mycorrhiza; or short-roots cooperating with deep roots; biochemical exchanges in the soil. I would expect these to show up as short-range interactions between plants, and these might be identified by examining the meadows data on a per-quadrat basis instead of aggregating by community, which is the usual procedure.

Load up some data ...
```{r}
# Libraries
library("RMySQL")
library(tidyverse)
# library(corrplot)
library(networkD3)
library(igraph)

# Functions
dbDisconnectAll <- function(){
  ile <- length(dbListConnections(MySQL())  )
  lapply( dbListConnections(MySQL()), function(x) dbDisconnect(x) )
  cat(sprintf("%s connection(s) closed.\n", ile))
}

# General SQL query
query <- function(q)
{
  # Remote DB with password
  con <- dbConnect(MySQL(), 
                   user  = "guest",
                   password    = "guest",
                   dbname="meadows",
                   port = 3306,
                   host   = "sxouse.ddns.net")
  rs1 = dbSendQuery(con, q)
  return(as_tibble(fetch(rs1, n=-1)))
  dbDisconnectAll()
}

# Load the database
GetTheData <-  function()
{
  # GET DATA FROM DB
  # Remote DB with password
  con <- dbConnect(MySQL(), 
                   user  = "guest",
                   password    = "guest",
                   dbname="meadows",
                   port = 3306,
                   host   = "sxouse.ddns.net")
  
  
  q <- sprintf('select assembly_id, assembly_name, quadrat_count, community, quadrat_id, visit_date, records_id, species.species_id, 
    species.species_name from assemblies
      join quadrats on quadrats.assembly_id = assemblies_id
      join visit_dates on quadrats.vd_id = visit_dates.vds_id
      join records on records.quadrat_id = quadrats_id
      join species on species.species_id = records.species_id
      # Two assemblies have 0 quadrat count; exclude A.capillaris_stolonifera;
      # exclude some odd assemblies with no assigned community
    where quadrat_count > 0 and species.species_id != 4 and community is not null;') 
      # NOTE: this extract includes "MG5", i.e. some MG5 communities where 
      # the team have not decided
      # on a sub-group.
  
  rs1 = dbSendQuery(con, q)
  return(as_tibble(fetch(rs1, n=-1)))
  dbDisconnectAll()
}

OddsRatio <-  function(d, A, B) # the_data, species_name, species_name
  # Not used yet. Need to check warnings.
{
  t <- d %>% filter(species_name %in% c(A, B))
  As <- t %>% filter(species_name == A)
  Bs <- t %>% filter(species_name == B)
  j1 <- full_join(As, Bs, by = "quadrat_id")
  # get all the quadrats, including ones with neither A nor B
  q <- d %>% distinct(quadrat_id) 
  j2 <- (left_join(q, j1, by = "quadrat_id") 
         # NOTE: column length q >= column length j1
         %>% mutate(AandB = !is.na(species_name.x) & !is.na(species_name.y))
         %>% mutate(AnotB = !is.na(species_name.x) & is.na(species_name.y))
         %>% mutate(BnotA = !is.na(species_name.y) & is.na(species_name.x))
         %>% mutate(neither = is.na(species_name.x) & is.na(species_name.y)))
  s <- colSums(j2[,4:7])
  return((s[1]*s[4])/(s[2]*s[3]))
}

# End of functions

d <- GetTheData()
# the_data <- d %>% filter(community == "MG5c")
the_data <- (d %>% filter(grepl("MG", community))
             %>% select(quadrat_id, species_name))
rm(d)
```
First suggestion: species (nodes) connected by commonality at the quadrat level.
```{r}
edges <- (full_join(the_data, the_data, by = "quadrat_id")
          %>% rename(from = species_name.x)
          %>% rename(to = species_name.y)
          %>%  select(-quadrat_id)
          %>% group_by(from, to) %>% summarise(wt = n())
          %>% filter(from != to))
nodes <- distinct(edges, from)
net <- graph_from_data_frame(d = edges, vertices = nodes, directed = F)
n2 <- simplify(net, edge.attr.comb = "ignore")
l <- layout.fruchterman.reingold(net)
plot(n2, layout=l, vertex.label=NA)

```
Note the simplify step above to eliminate duplicated edges (e.g. Holcus -> Arrhenatherum, Arrhenaetherum -> Holcus). This results in a much more manageable graph. This now looks like getiing interesting as modularity is not negligible (~0.001) and cluster_walktrap shows some modules:
```{r}
wc <- cluster_walktrap(n2)
modularity(wc)
plot(wc, n2, vertex.label=NA)

```
which with some fiddling with the plot parameters resolves into a complex set of modules:
```{r}
plot(wc, n2, vertex.label=NA, vertex.size = 2, rescale = T, edge.color = NA)
```
So, this is rather interesting. We would like to know more about that little group of four plants at about 10 o'clock, and th much larger orange clump between 6:00 and 8:00, a little more central. We note that bigger modules occur centrally with many isolated plants peripherally, presumably the central species are more densely connected. More urgently, however, it seems sensible to narrow down the search for interacting plants in some way; also to see whether the modules are a short range phenomenon. Would a similar structure persist if we looked at co-occurrence at the assembly level? Probably it would, but maybe there are some modules that depend on short-range interactions that may be less obvious with aggregation at the assembly level (at least 5 quadrats, widely spaced). Could look at within-quadrat assocation vs between-quadrat association?

Need a function for odds ratio given a pair of species. (Written and inserted at head of notebook but not used yet).

